<div id="sankey-body">
    <div id="topbar"></div>
    <div id="content"></div>
</div>

{% load static %}

<!-- for offline use (leave commented when you commit!) -->
<!--<script src="{% static 'sankey/d3.v5.min.js' %}"></script>-->
<!-- for online use -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.js"></script>

<script src="{% static 'sankey/sankey.js' %}"></script>
<!-- change to setupHorizontal to rotate -->
<script src="{% static 'sankey/setupVertical.js' %}"></script>
<script> {{ sankeyjs|safe }} </script>
<script>

    // TODO
    // 1. how to mouseover <text> in the middle of the sankey?

// Below are crazy heuristics to try to get the graph to look good
// on a variety of sizes.
var units = "Votes";
var nodePadding = 20 + 0.5*Math.min(numCandidates,10) // the more candidates, the more room you want to display connections.
var linkPadding = 50
var roundSize0 = nodeSize0 + nodePadding + linkPadding
var totalSize0 = (numRounds) * roundSize0
var idealTotalSize1 = Math.min(numCandidates,5)*avgNodeSize1 + Math.max(numCandidates-5,0)*30
var size1TopbarTextPadding = 300; // allow room for long text on last candidate
var heightUntilSticky = 200; // how far you scroll down before the top bar "sticks" to the top

var ESTIMATED_CHAR_WIDTH = 13; // yikes this is not correct

// set the dimensions and margins of the graph
var cmargin = {top:  0, right: 10, bottom: 15, left: 50}, // content
    tmargin = {top:  0,                        left: 50}, // topbar
{% if config.rotateNames %}
    tmarginLength = longestLabelApxWidth * ESTIMATED_CHAR_WIDTH + 5, // +5 handles one-char names well
    rotationOffset = tmarginLength*.7071067,
{% else %}
    tmarginLength = 40,
{% endif %}
    size0 = totalSize0 + size0margin(cmargin),
    hackExtraPadding = numCandidates*30, // we need extra room because the
                                         // ideal size may not be the actual size
                                         // once all the nodes are expanded to their minimum sizes
    size1 = idealTotalSize1 + size1margin(cmargin) + hackExtraPadding;

function hackCharsForWidth(width, text) {
    var length = width/ESTIMATED_CHAR_WIDTH
    if(length >= text.length - 3) {
        return text;
    } else {
        return text.substring(0, length) + "...";
    }
}
function getNodeLabelText(d) {
    return d.name;
}
function getNodeLabelTextTruncated(d) {
    return hackCharsForWidth(d.dx, d.name);
}
function textForNode(d) {
    var s = "";
    if(d.isEliminated)
        s += "❌ " ;
    if(d.isWinner)
        s += "✅ " ;
    s += ""+Math.round(d.value*100)/100.0;
    return s;
}

function getNodeValueText(d) {
    return textForNode(d)
}
function getNodeValueTextTruncated(d) {
    return hackCharsForWidth(d.dx, textForNode(d))
}

function makeGraph(graph) {
    // format variables
    var formatNumber = d3.format(",.0f"),    // zero decimal places
        format = function(d) { return formatNumber(d) + " " + units; };

    // append the svg object to the body of the page
    var svg = d3.select("#sankey-body").append("svg")
        .attr(size0string(), size0 + size0margin(cmargin))
        .attr(size1string(), size1 + size1margin(cmargin))
      .append("g")
        .attr("transform", 
              "translate(" + cmargin.left + "," + cmargin.top + ")");

    // Set the sankey diagram properties
    var sankey = d3.sankey()
        .nodeSize0(nodeSize0)
        .nodePadding(nodePadding)
        .size([0, idealTotalSize1]);

    var path = sankey.link();

    sankey
      .nodes(graph.nodes)
      .links(graph.links)
      .layout(32);

    // the function for moving the nodes
    function dragmove(d) {
        var translate0 = dim0(d);
        var translate1 = (set_dim1(d, Math.max(
                          0, Math.min(size1 - ddim1(d), dim1(d3.event))))
                         );
        commad = commaSeparate(translate0, translate1)
        d3.select(this)
          .attr("transform", 
                "translate(" + commad + ")");
        sankey.relayout();
        link.attr("d", path);
    }

    // add in the links
    var link = svg.append("g").selectAll(".link")
      .data(graph.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", path)
      .style("fill", function(d) { return d3.rgb(d.color) })
      .sort(function(a, b) { return ddim1(b) - ddim1(a); });

    // add the link titles
    link.append("title")
        .text(function(d) {
            return format(d.value); });

    // add in the nodes
    var node = svg.append("g").selectAll(".node")
      .data(graph.nodes)
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { 
          commad = commaSeparate(dim0(d), dim1(d))
          return "translate(" + commad + ")"; })
      .call(d3.drag()
        .subject(function(d) {
          return d;
        })
        .on("start", function() {
          this.parentNode.appendChild(this);
        })
        .on("drag", dragmove));

    svg.append("g").selectAll(".roundLabels")
        // TODO we shouldn't assume dim1 is at zero but
        // this is the easiest way to get unique values
        // and computing the height based on nodeSize0
        // didn't work for some reason?
      .data(graph.nodes.filter(function(d){return dim1(d) == 0;}))
      .enter().append("text")
      .attr("class", 'roundLabels' )
      .attr("x", function(d) {
            return avgNodeSize1 * 1.5
       } )
      .attr("y", function(d) {
            return dim0(d) - roundSize0*0.2;
       } )
      .text(function(d) { return "Round " + d.round });

    // add the rectangles for the nodes
    node.append("rect")
      .attr(size1string(), function(d) { return ddim1(d); })
      .attr(size0string(), sankey.nodeSize0())
      .style("fill", function(d) { return d.color })
    .append("title")
      .text(function(d) { 
          return d.name + "\n" + format(d.value); });

    // add in the title for the nodes
    var SHIFT_TEXT_LEFT_IF_WIDTH_LESS_THAN = 100;
    node.append('g').append("text")
      .attr("x", function(d) { if(ddim1(d) > SHIFT_TEXT_LEFT_IF_WIDTH_LESS_THAN) return textXPos; return -3; } ) // small nodes shouldn't be shifted to save space
      .attr("y", textYPos )
      .attr("dy", ".35em")
      .style("pointer-events", "all")
      .text(getNodeValueTextTruncated)
          .on('mouseover', function(d){
              d3.select(this).text(getNodeValueText);
          })
          .on('mouseout', function(d){
              d3.select(this).text(getNodeValueTextTruncated);
          })
        .call(d3.drag());
}

function makeTopBar(graph) {
    var lastRound = -1;
    var topbarG = d3.select('#topbar').append("svg")
        .attr(size0string(), tmarginLength)
        .attr(size1string(), size1+size1TopbarTextPadding)
        .attr("transform", 
              "translate(" + tmargin.left + "," + tmargin.top + ")" ,
        )
        .append("g");
    return topbarG;
}

function populateTopBarFor(topbarG, round) {
    lastRound = round;
    var data = graph.nodes.filter(function(d){return d.round == round;});
    var topbar = topbarG
      .selectAll(".topbar_element")
      .data(data, function(d) { return d; });

    topbar.enter().append("g")
      .attr('class', 'topbar_element')
      .attr("transform", function(d) { 
          commad = commaSeparate(0, dim1(d))
          return "translate(" + commad + ")"; })
      .attr(size1string(), function(d) { return ddim1(d); })
      .attr(size0string(), nodeSize0)
      .append("text")
      {% if config.rotateNames %}
      .attr("dx", -rotationOffset + 5)
      .attr("dy", rotationOffset + 5)
      .attr("transform", "rotate(-45)")
      .text(getNodeLabelText)
      {% else %}
      .attr("x", 0 )
      .attr("y", 30 )
      .attr("dy", ".35em")
      .text(getNodeLabelTextTruncated)
        .on('mouseover', function(d){
            d3.select(this).text(getNodeLabelText);
        })
        .on('mouseout', function(d){
            d3.select(this).text(getNodeLabelTextTruncated);
        })
        .call(d3.drag());
      {% endif %}
    topbar.exit().remove();
}

function getBodyMarginInt() {
    var style = window.getComputedStyle(document.body);
    var bodyMargin = style.getPropertyValue('margin-left');
    return parseInt(bodyMargin, 10);
}

function notifyScrolled() {
  // TODO this only supports vertical sankey mode
  var x = -window.pageXOffset + bodyMargin;
  if (window.pageYOffset >= sticky) {
    topbarDiv.classList.add("sticky")
  } else {
    topbarDiv.classList.remove("sticky");
  }
  topbarDiv.style.left = x+"px"; 
  var round = (window.pageYOffset + tmarginLength)/roundSize0 - cmargin.top
  round = Math.floor(round);
  round = Math.min(round, numRounds)
  round = Math.max(round - 1, 0)
  if(round != lastRound) {
      populateTopBarFor(topbarG, round)
  }
}

window.onscroll = function() {notifyScrolled()};

var topbarDiv = document.getElementById("topbar");
var sticky = topbarDiv.offsetTop + heightUntilSticky;
var bodyMargin = getBodyMarginInt()
makeGraph(graph);
var topbarG = makeTopBar(graph);
populateTopBarFor(topbarG, 0)

</script>
